	Para a primeira versão do nosso software faremos a parte que cuidará das funções de captação, transcrição e
salvamento das informações de entrada e saída especificada. As funções de captação de áudio sera definida pela classe
"capta_audio" que poderá obter o áudio, seja ele por um arquivo ou entrada de voz pelo microfone suas respectivas funções
são "def entrada_microfone" e "def entrada_file".
	Já na transcrição entrará o módulo da API "SpeechRecognition" reponsável por nos fornecer as funções de transformação
do áudio em texto. O método  a ser utilizado será "Recognizer" implicitamente na função (def entrada_microfone) já aplicada na classe "capta_audio" a função em si é
capacitada para o recebimento dos dados em audio pelo microfone do usuário, onde definimos um objetos chamado "reconhecedor" que recebe a atribuição do contéudo captado e
tratado pelo método "Recognizer" até então ele fica armazenado na instância do objeto, logo em seguida utilizamos o recurso nativo do Python comando próprio da sínta 
xe conhecido como "with" que é capaz de iniciar um recurso ou serviço da máquina, caso ele atenda a requisição feita no código ou não, ele garante a queda(fechamento)
do mesmo tornando desnecessário o uso do (objeto.close()), comando em outras linguagens conhecido também como "finally", através dele iniciamos o funcionamento do microfone atribuindo um "allias" ao dispositivo com o
nome de (micro), após essa chamada tratamos o fluxo do áudio ainda encima do objeto "reconhecedor" através da função "adjust_for_ambient_noise"  como seu próprio nome já
diz a mesma proporciona um tratamento de retirada de rúidos do ambiente mais constantes na captação que impossibilitam a má interpretação do conteúdo e finalização do 
serviço acionado. Finalizando este bloco instanciamos o objeto "audio" que é atribuído com o uso do objeto "reconhecedor" condicionado a função (listen) responsável pela 
interpretação do conteúdo recebido pelo microfone "allias (micro)".
	Mesmo sendo feita a entrada através do microfone é necessário que seja salvo o conteúdo captado no momento, pois isso no proporciona uma vasta gama de possibilidades
para lidar com os dados recebidos, uma obviedade sem muitos mistérios, acredita-se que ninguém deseja perder o conteúdo original que o dispositivo recebeu, pensando
nessa necessidade resolvemos criar um bloco responsável por salvar o arquivo nativo da entrada, para isso foi preciso que instanciássemos um objeto chamado "name_filewav"
através deles salvamos as informações num arquivo de audio (.wav) por ser um arquivo de audio não comprimido possui uma melhor fidelidade no som reproduzido, proporcionando
uma análise e consequentemente uma transcrição mais fidedigna. Novamente iniciamos o serviço de criação de arquivo pelo comando "with" dessa vez para criar o respectivo
audio  usamos a função "write" para transmitir as informações para o "file" desse modo o parâmetro usado na função é o "AudioData" nele é passado o objeto em si seguido do
método (get_wav_data().